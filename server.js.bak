const path = require('path');
const express = require('express');
const http = require('http');
const WebSocket = require('ws');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const logger = require('./logger');
const cors = require('corwss.on('connection', (ws, req) => {
  try {
    // Лимит соединений с одного IP
    const ip = req.socket.remoteAddress;
    const currentConnections = wsConnections.get(ip) || 0;
    if (currentConnections >= WS_MAX_CONNECTIONS_PER_IP) {
      logger.logWebSocketEvent('connection_rejected', { ip, reason: 'too_many_connections' });
      ws.close(1008, 'Too many connections');
      return;
    }
    wsConnections.set(ip, currentConnections + 1);
    
    ws.isAuthed = false;
    clients.add(ws);
    
    // Пинг для поддержания соединения
    ws.isAlive = true;
    ws.on('pong', () => { ws.isAlive = true; });
    
    logger.logWebSocketEvent('connection_accepted', { ip });
    ws.send(JSON.stringify({type:'info', text:'Connected to integrated server.'}));it = require('express-rate-limit');
const helmet = require('helmet');
const logger = require('./logger');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware для логирования HTTP запросов
app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    const responseTime = Date.now() - start;
    logger.logHttpRequest(req, res, responseTime);
  });
  next();
});

// Базовая защита заголовков
app.use(helmet());

// Настройка CORS
const corsOptions = {
  origin: process.env.ALLOWED_ORIGINS ? process.env.ALLOWED_ORIGINS.split(',') : '*',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization', 'x-auth-token'],
  maxAge: 86400 // 24 часа кэширования preflight
};
app.use(cors(corsOptions));

// Rate limiting
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 минут
  max: 100, // Лимит 100 запросов с одного IP
  message: { error: 'Too many requests, please try again later.' }
});
app.use('/api/', apiLimiter);

// Парсинг JSON с лимитом размера
app.use(express.json({ limit: '10kb' }));

let db = null;
try{
  db = require('./db');
  console.log('Using SQLite database (./db)');
}catch(e){
  db = require('./filedb');
  console.log('SQLite DB not available, using file-based fallback (./filedb)');
}
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-key';

function checkToken(req, res, next){
  const token = req.headers['x-auth-token'] || req.query.token;
  if(token && token === (process.env.EXAMPLE_TOKEN || 'secret-token')) return next();
  const auth = req.headers['authorization'];
  if(auth && auth.startsWith('Bearer ')){
    const t = auth.slice(7);
    try{ const payload = jwt.verify(t, JWT_SECRET); req.user = payload; return next(); }catch(e){}
  }
  return res.status(401).json({error:'unauthorized'});
}

function requireAdmin(req, res, next){ if(req.user && req.user.role === 'admin') return next(); return res.status(403).json({error:'forbidden'}); }

// Commands API
app.get('/api/commands', checkToken, (req, res) => {
  const rows = db.prepare('SELECT name,payload FROM commands').all();
  const obj = {};
  for(const r of rows) obj[r.name] = r.payload;
  res.json(obj);
});

app.post('/api/commands', checkToken, requireAdmin, (req, res) => {
  const { name, payload } = req.body;
  if(!name || !payload) return res.status(400).json({error:'invalid'});
  db.prepare('INSERT OR REPLACE INTO commands (name,payload) VALUES (?,?)').run(name, payload);
  res.json({ok:true});
});

app.delete('/api/commands/:name', checkToken, requireAdmin, (req, res) => {
  const name = req.params.name;
  db.prepare('DELETE FROM commands WHERE name = ?').run(name);
  res.json({ok:true});
});

// Auth: register + login
app.post('/api/register', express.json(), async (req, res) =>{
  const {username, password} = req.body; if(!username||!password) return res.status(400).json({error:'invalid'});
  const hashed = await bcrypt.hash(password, 8);
  try{
    // If no users exist yet, make the first user an admin; otherwise regular 'user'
    const count = db.prepare('SELECT COUNT(*) as c FROM users').get().c;
    const role = count === 0 ? 'admin' : 'user';
    const info = db.prepare('INSERT INTO users (username,password,role) VALUES (?,?,?)').run(username, hashed, role);
    // return token on successful registration to simplify frontend flow
    const token = jwt.sign({id: info.lastInsertRowid, username, role}, JWT_SECRET, {expiresIn:'8h'});
    return res.json({ok:true, token});
  }catch(e){ return res.status(400).json({error:'exists'}); }
});

// Settings API
app.get('/api/settings', checkToken, (req, res) => {
  const rows = db.prepare('SELECT key,value FROM settings').all();
  const obj = {};
  for(const r of rows){
    try{ obj[r.key] = JSON.parse(r.value); }catch(e){ obj[r.key] = r.value; }
  }
  res.json(obj);
});

app.put('/api/settings', checkToken, requireAdmin, express.json(), (req, res) => {
  const body = req.body || {};
  const insert = db.prepare('INSERT OR REPLACE INTO settings (key,value) VALUES (?,?)');
  try{
    db.transaction(() => {
      for(const k of Object.keys(body)) insert.run(k, JSON.stringify(body[k]));
    })();
    res.json({ok:true});
  }catch(e){ res.status(500).json({error:'failed'}); }
});

app.post('/api/login', express.json(), async (req,res)=>{
  const {username,password} = req.body; if(!username||!password) return res.status(400).json({error:'invalid'});
  const row = db.prepare('SELECT id,username,password,role FROM users WHERE username = ?').get(username);
  if(!row) return res.status(401).json({error:'invalid'});
  const ok = await bcrypt.compare(password, row.password);
  if(!ok) return res.status(401).json({error:'invalid'});
  const token = jwt.sign({id:row.id,username:row.username,role:row.role}, JWT_SECRET, {expiresIn:'8h'});
  res.json({token});
});

// Current user info
app.get('/api/me', checkToken, (req, res) => {
  if(req.user) return res.json({id: req.user.id, username: req.user.username, role: req.user.role});
  return res.status(401).json({error:'unauthorized'});
});

// serve dashboard statics
app.use('/', express.static(path.join(__dirname, 'twitch-bot-dashboard')));

const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

const VALID_TOKEN = process.env.EXAMPLE_TOKEN || 'secret-token';

// Храним активные WS соединения для возможности широковещательной рассылки
const clients = new Set();

// Лимит на количество одновременных соединений с одного IP
const wsConnections = new Map();
const WS_MAX_CONNECTIONS_PER_IP = 3;

wss.on('connection', (ws, req) => {
  try {
    // Лимит соединений с одного IP
    const ip = req.socket.remoteAddress;
    const currentConnections = wsConnections.get(ip) || 0;
    if (currentConnections >= WS_MAX_CONNECTIONS_PER_IP) {
      ws.close(1008, 'Too many connections');
      return;
    }
    wsConnections.set(ip, currentConnections + 1);
    
    ws.isAuthed = false;
    clients.add(ws);
    
    // Пинг для поддержания соединения
    ws.isAlive = true;
    ws.on('pong', () => { ws.isAlive = true; });
    
    ws.send(JSON.stringify({type:'info', text:'Connected to integrated server.'}));
    logger.logWebSocketEvent('connection', { ip });
  ws.on('message', (m) => {
    let data = null;
    try { data = JSON.parse(m); } catch(e){ ws.send(JSON.stringify({type:'error', text:'invalid json'})); return; }
    if(data.type === 'auth'){ if(data.token === VALID_TOKEN){ ws.isAuthed = true; ws.send(JSON.stringify({type:'auth', ok:true})); } else ws.send(JSON.stringify({type:'auth', ok:false, reason:'invalid token'})); return; }
    if(!ws.isAuthed){ ws.send(JSON.stringify({type:'error', text:'not authenticated'})); return; }
    if(data.type === 'say'){ console.log('[say]', data.text); ws.send(JSON.stringify({type:'ok', text:'message delivered'})); }
    else if(data.type === 'custom'){ console.log('[custom]', data.cmd, data.text); ws.send(JSON.stringify({type:'ok', text:`custom ${data.cmd} executed`})); }
    else ws.send(JSON.stringify({type:'error', text:'unknown command'}));
  });
});

// Пинг всех клиентов каждые 30 секунд
const interval = setInterval(() => {
  wss.clients.forEach((ws) => {
    if (!ws.isAlive) {
      clients.delete(ws);
      return ws.terminate();
    }
    ws.isAlive = false;
    ws.ping();
  });
}, 30000);

// Очистка интервала при остановке сервера
wss.on('close', () => {
  clearInterval(interval);
});

server.listen(PORT, () => console.log(`Server running http://localhost:${PORT}`));
